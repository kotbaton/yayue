# import sys      # needed from stdout
# import os
# import numpy as np
import pandas as pd
from par_plot import *


class ParSol:     # one Pareto solution
    def __init__(self, itr_id, vals, a_vals, sc_vals):
        self.itr_id = itr_id    # iteration id (negative for corners)
        self.vals = vals  # list of criteria values
        self.a_vals = a_vals  # list of achievement values
        self.sc_vals = sc_vals  # list of scaled criteria values
        print(f'Solution of itr {itr_id}: criteria values: {self.vals}, (scaled: {self.sc_vals})')


class Cube:     # defined (in scaled values) by the two given neighbor solutions
    def __init__(self, mc, s1, s2):
        self.mc = mc    # CtrMca object
        self.s1 = s1    # first solution defining the cube
        self.s2 = s2    # second solution defining the cube
        self.size = 0.    # cube size = L1 distance(s1, s2), for scaled crit values
        self.sc_asp = []   # list of scaled A values (used in defining solutions that define the cube)
        self.sc_res = []   # list of scaled R values
        self.asp = []   # list of A values (to be used in the MCMA preferences)
        self.res = []   # list of R values

        # calculate the cube size
        for (a1, a2) in zip(s1.sc_vals, s2.sc_vals):  # loop over scaled values of criteria
            self.size += abs(a1 - a2)  # Manhattan (L1) distance in criteria scaled-values

    # define A/R values for spliting the cuboid (i.e., to find a new solution between s1 and s2)
    def setAR(self):
        for (i, cr) in enumerate(self.mc.cr):
            v1 = self.s1.vals[i]
            v2 = self.s2.vals[i]
            if cr.isBetter(v1, v2):     # s1 has better crit. value than s2
                cr.asp = v1
                cr.res = v2
                self.asp.append(v1)
                self.res.append(v2)
                self.sc_asp.append(cr.sc_var * v1)
                self.sc_res.append(cr.sc_var * v2)
            else:           # s2 has better crit. value than s1
                cr.asp = v2
                cr.res = v1
                self.asp.append(v2)
                self.res.append(v1)
                self.sc_asp.append(cr.sc_var * v2)
                self.sc_res.append(cr.sc_var * v1)
            cr.is_active = True
            print(f'New cube A/R values for criterion {cr.name}: A {cr.asp:.3e}, R {cr.res:.3e}')

    def lst(self, seq):
        val1 = ''
        val2 = ''
        for (v1, v2) in zip(self.s1.vals, self.s2.vals):
            val1 += f'{v1:.2e}, '
            val2 += f'{v2:.2e}, '
        print(f'cube[{seq}, size={self.size:.2e}, sol_itrIds: ({self.s1.itr_id}, {self.s2.itr_id}), '
              f'corners: ([{val1}], [{val2}])')

        val1 = ''
        val2 = ''
        for (v1, v2) in zip(self.sc_asp, self.sc_res):
            val1 += f'{v1:.2e}, '
            val2 += f'{v2:.2e}, '
        print(f'\tNext preferences:  A [{val1}],  R [{val2}]')


class ParRep:     # representation of Pareto set
    def __init__(self, mc):
        self.mc = mc    # CtrMca object
        # self.n_crit = mc.n_crit   # number of criteria  (not needed?)
        # self.n_corners = 0   # number of corners (one utopia + other inactive)
        self.sols = []      # Pareto-solutions (ParSol objects)
        self.neigh = []     # list of tuples (itr_id1, itr_id2, distance) to the nearest neighbor
        self.cubes = []     # list of cubes (Cube objects, one cube for each iteration)
        self.df_sol = None  # df with solutions prepared for plots

        mc.scale()          # (re)define scales for criteria values
        self.ini_corners()  # initialize corner solutions
        # raise Exception(f'ParRep ctor not implemented yet.')

    def pref(self):     # entry point for each iteration
        # define the largest cube (including new A/R definition directly in the mc.cr)

        # explore cubes generated by all pairs of solutions, exclude cubes with an inside solution(s)
        cube_lst = []   # list of all cubes without any solution inside
        for (i, s1) in enumerate(self.sols):
            j = i + 1
            while j < len(self.sols):
                print(f'checking cube generated by solutions: ({i}, {j}).')
                s2 = self.sols[j]
                is_inside = False   # solution inside the cube exists
                for (k, s) in enumerate(self.sols):     # check, if any solution is inside cube(s1, s2)
                    if k == i or k == j:
                        continue    # skip checking the corners
                    # check, if k-th solution is inside cube generated by solutions (i, j)
                    is_inside = self.chk_inside(s, s1, s2)
                    if is_inside:
                        break   # don't check the remaining solutions
                if not is_inside:
                    cube_lst.append(Cube(self.mc, s1, s2))
                    print(f'Cube generated by solutions ({i}, {j}) added to the candidates for the largest cube.')
                else:
                    # noinspection PyUnboundLocalVariable
                    print(f'Cube generated by solutions ({i}, {j}) skipped (has {k}-th solution inside).')
                j += 1
        mx_size = 0.    # size of largest cube found so far
        c_best = None
        for c in cube_lst:
            if c_best is None:
                c_best = c
                mx_size = c.size
            else:
                if c.size > mx_size:
                    c_best = c
                    mx_size = c.size
        if c_best is None:
            raise Exception(f'ParRep::pref(): no cube defined.')

        c_best.setAR()  # set AR in mc.cr and store them in the cube
        self.cubes.append(c_best)
        print(f'The largest out of {len(cube_lst)} cubes has size = {mx_size}')

    def chk_inside(self, s, s1, s2):    # return True if s is inside cube(s1, s2)
        it = s.itr_id
        it1 = s1.itr_id
        it2 = s2.itr_id
        for (i, cr) in enumerate(self.mc.cr):
            v = s.vals[i]
            v1 = s1.vals[i]
            v2 = s2.vals[i]
            if not min(v1, v2) < v < max(v1, v2):
                print(f'crit {cr.name}: {v} is outside range of ({v1}, {v2}).')
                return False  # v outside the range [v1, v2]
            else:
                print(f'crit {cr.name}: {v} is in the range of ({v1}, {v2}); continue check.')
        print(f'solution {it} is between solutions ({it1}, {it2}).')
        return True    # all crit-vals of s are between the corresponding values of s1 and s2
        # raise Exception(f'ParRep::chk_inside() not implemented yeYt.')

    def cube(self):     # not good, therefore no longer used
        # define new cube (in ASF space), set A/R (in both ASF and A/R scales)
        # self.nearest()    # called either by ctor or by addSol(); find pairs of neighbors (nearest solutions)
        # find pairs of most distant neighbor solutions, i.e., largest gap in the solutions (to define new cube)
        mx_dis = 0.    # initialize distance
        s1 = None   # initialize solutions to undefined
        s2 = None
        itr1 = None
        itr2 = None
        for (i, n1) in enumerate(self.neigh):
            dis = n1[2]  # distance is the third arg in the list element (itr1, utr2, distanse)
            if dis > mx_dis:
                itr1 = n1[0]    # itr_id of the "from" solution
                itr2 = n1[1]    # itr_id of the "to" solution
                s1 = self.sol_seq(itr1)   # sol_seq of the first solution
                s2 = self.sol_seq(itr2)   # sol_seq of the second solution
                mx_dis = dis
        assert mx_dis > 0., f'ParRep::cube(): empty cube.'
        print(f'Largest cube defined by solutions: {s1} (itr {itr1}), {s2} (itr {itr2}); cube size = {mx_dis}.')
        self.cubes.append(Cube(self.mc, self.sols[s1], self.sols[s2]))     # ctor sets A/R values in mc.cr
        print(f'Cube added to ParRep. There are {len(self.cubes)} cubes defined.')
        # raise Exception(f'ParRep::cube() not implemented yet.')

    def addSol(self, itr_id):  # add solution (uses crit-values updated in mc.cr)
        vals = []     # crit values
        a_vals = []     # crit values
        sc_vals = []  # scaled crit values
        for cr in self.mc.cr:
            vals.append(cr.val)
            sc_vals.append(cr.sc_var * cr.val)
        for cr in self.mc.cr:   # compute achievement values
            sc = self.mc.cafAsp / abs(cr.utopia - cr.nadir)
            # todo: if correct also for negative U, N, then the below can be simplified by using the cr.mult
            if cr.mult == 1:    # maximized crit.
                a_val = sc * (cr.utopia - cr.val)
            else:
                a_val = sc * (cr.val - cr.utopia)
            a_vals.append(a_val)
            a_frac = abs(sc * cr.val)  # value as a fraction of the range
            print(f'crit {cr.name} ({cr.attr}): {a_val=}, val = {cr.val}, {a_frac}, U {cr.utopia}, N {cr.nadir}')
        self.sols.append(ParSol(itr_id, vals, a_vals, sc_vals))
        print(f'Solution {itr_id = } added to ParRep. There are {len(self.sols)} Pareto solutions.')
        # todo: implement update while adding new solutions (instead of computing all)
        # self.nearest()      # find pairs of neighbors (nearest solutions)
        # raise Exception(f'ParRep::addSol() not implemented yet.')

    def ini_corners(self):  # initialize corner solutions (each composed of one utopia and nadir of all others)
        cur_uto = 0     # index of the current utopia
        for (k, crit) in enumerate(self.mc.cr):     # one corner for each criterion
            vals = []  # crit values
            a_vals = []  # achievement values
            sc_vals = []  # scaled crit values (one utopia, others nadir)
            itr_id = -1 - k  # itr_id negative, start with -1
            for (i, cr) in enumerate(self.mc.cr):
                if i == cur_uto:
                    val = cr.utopia
                    a_val = self.mc.cafAsp  # value of CAF at A
                    sc_val = cr.sc_var * val
                else:
                    val = cr.nadir
                    a_val = 0.
                    sc_val = cr.sc_var * val
                vals.append(val)
                a_vals.append(a_val)
                sc_vals.append(sc_val)
            self.sols.append(ParSol(itr_id, vals, a_vals, sc_vals))
            cur_uto += 1

    def nearest(self):  # for each solution find distance (in ASF scale) to the nearest neighbor
        # todo: consider update of self.neigh while adding one new solution (instead of computing all)
        self.neigh = []
        mx_gap = 0.     # max gap
        min_gap = float('inf')  # min gap
        no_gap = 0      # number of zero-gaps
        it1 = it2 = it3 = it4 = None
        for (i, s1) in enumerate(self.sols):
            dist = float('inf')
            nearest = None
            for (j, s2) in enumerate(self.sols):
                if i == j:
                    continue
                s2 = self.sols[j]
                d = 0.
                for (a1, a2) in zip(s1.sc_vals, s2.sc_vals):    # loop over scaled values of criteria
                    d += abs(a1 - a2)   # Manhattan (L1) distance in criteria scaled-values
                if d < dist:
                    nearest = j     # seq_no in self.sols
                    dist = d
                else:
                    # print(f'pair of solution_seq ({i}, {j}), dist {d} skipped: current min dist = {dist}')
                    pass
                j += 1
            assert nearest is not None, f'ParRep::nearest(): neighbor not found for {i}-th solution.'
            itr1 = self.sols[i].itr_id
            itr2 = self.sols[nearest].itr_id
            self.neigh.append([itr1, itr2, dist])
            if dist > mx_gap:
                mx_gap = dist
                it1 = itr1
                it2 = itr2
            if dist < min_gap:
                if dist > 0.:
                    min_gap = dist
                    it3 = itr1
                    it4 = itr2
                else:
                    no_gap += 1
        n_lst = ''
        for ne in self.neigh:
            n_lst += f'[{ne[0]}, {ne[1]}, {ne[2]:.2e}], '
        print(f'Distances to nearest sol. (itr_id1, itr_id2, dist): {n_lst}')
        # print(f'\nDistances to nearest sol. (itr_id1, itr_id2, dist): {self.neigh}')
        print(f'Max gap {mx_gap:.2e} for neighbor itr_ids ({it1}, {it2}).')
        print(f'Min non-zero gap {min_gap:.2e} for neighbor itr_ids ({it3}, {it4}).')
        print(f'Number of zero-gaps {no_gap}.')

    def sol_seq(self, itr_id):  # return seq_no in self.sols[] for the itr_id
        for (i, s) in enumerate(self.sols):
            if s.itr_id == itr_id:
                return i
        raise Exception(f'ParRep::sol_seq(): {itr_id} not in the solution set.')

    def lst_cubes(self):  # lisrt cubes
        for (i, c) in enumerate(self.cubes):
            c.lst(i)

    def summary(self):  # summary report
        print('\nList of cubes:')
        self.lst_cubes()
        print('\n')

        # prepare df with solutions for plot2D
        cols = ['itr_id']
        for cr in self.mc.cr:   # space for criteria values
            cols.append(cr.name)
        for cr in self.mc.cr:   # space for criteria achievements
            cols.append('a_' + cr.name)
        self.df_sol = pd.DataFrame(columns=cols)
        for s in self.sols:
            new_row = {'itr_id': s.itr_id}
            for (i, cr) in enumerate(self.mc.cr):
                new_row.update({cr.name: s.vals[i]})
                new_row.update({'a_' + cr.name: s.a_vals[i]})
            df2 = pd.DataFrame(new_row, index=list(range(1)))
            self.df_sol = pd.concat([self.df_sol, df2], axis=0, ignore_index=True)
        f_name = self.mc.ana_dir + '/sol_df.csv'
        self.df_sol.to_csv(f_name, index=True)
        print(f'Solutions stored in the csv file: {f_name}.')

        # plot solutions
        plot2D(self.df_sol, self.mc.ana_dir)    # 2D plot

        # todo: 3D plots need reconfiguration: either the default browser or Safari version: either Safari beta
        # todo: or safari technology preview (see the Notes)
        # self.plot3()
        # self.plot3a()
        raise Exception(f'ParRep::summary() not implemented yeYt.')
